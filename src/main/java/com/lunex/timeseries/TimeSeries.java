package com.lunex.timeseries;

import com.google.common.collect.Ordering;

import com.lunex.timeseries.element.BaseDataElement;
import com.lunex.timeseries.element.DataElement;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 * In-memory version of timeseries, whatever added will just be in the Array and will not get
 * expired out if seriesSize is not set. To expired old bucket, set seriesSize to have fix memory
 * usage.
 */
public class TimeSeries<T extends DataElement> extends TimeSeriesBase<T>
    implements TimeDataset<T>, Iterable<T> {

  private final Logger log = LoggerFactory.getLogger(TimeSeries.class);

  private List<T> list = new ArrayList();
  private T current = null;
  private T last = null;
  private TimeSchedule schedule = null;
  private int deleteOffset;
  private int seriesSize = -1;
  private long nextTime;
  //set this to a fix number to prevent over memory usage. default t0 100000

  public TimeSeries(String key, int elementSize) {
    this(key, elementSize, AggregateType.avg, 100000);
  }

  public TimeSeries(String key, int elementSize, AggregateType type, int seriesSize) {
    this(key, type, new TimeSchedule.AllDayAllWeek(elementSize), seriesSize);
  }

  public TimeSeries(String key, AggregateType type, TimeSchedule schedule, int seriesSize) {
    this.key = key;
    this.elementSize = schedule.elementSize;
    this.type = type;
    this.seriesSize = seriesSize;
    this.schedule = schedule;
  }

  public TimeSeries(String key, TimeSeries series){
    this(key, series.type, series.schedule, series.seriesSize);
  }

  public void addElement(T element){
    last = element;
    list.add(element);
  }
  /**
   * reason for having time, and event.getTime().  Time is controlled by the system, so we will not
   * go backward or out of order. event.getTime() is generated by client, so they can send us a
   * packet 1 hour late. late event that are not withint the current will be rejected.
   *
   * @param time - the time generate by the sender, it might not necessary be the time of the event
   * @param event - the time Event object
   * @return
   */
  public int onEvent(long time, TimeEvent event) {
//    log.debug("event {} next {} cur {}", TimeSeriesUtil.timetoStr(event.getTime()), TimeSeriesUtil.timetoStr(next), TimeSeriesUtil.timetoStr(current.getTime()));
    int numAdded = 0;
    if ((time - current.getTime() >= elementSize)) {
      //the new event is
      long ttime = truncate(time);
      nextTime = schedule.next(ttime);
      log.debug("event {} next {} cur {}", TimeSeriesUtil.timetoStr(time),
                TimeSeriesUtil.timetoStr(nextTime), TimeSeriesUtil.timetoStr(current.getTime()));

      if (nextTime > ttime + elementSize) {
        //rejected by schedule
        return -2;
      }

      //no phantom
//      last = current;
//      current = makeElement();
//      current.setTime(ttime);
//
//      list.add(current);

      //create phantom
      while (true) {
        //create phantom
        long currentNext = schedule.next(current.getTime());
        if (currentNext > ttime) {
          break;
        }
        last = current;
        current = makeElement();
        current.setTime(currentNext);
        list.add(current);
        numAdded++;
      }

      if (seriesSize != -1) {
//        long cutofftime = current().getTime() - elementSize * seriesSize;
        long cutofftime = schedule.prev(current.getTime(), seriesSize);
        if (cutofftime != -1) {

          while (first().getTime() < cutofftime) {
            log.debug("{} < {}", TimeSeriesUtil.timetoStr(first().getTime()),
                      TimeSeriesUtil.timetoStr(cutofftime));
            list.remove(0);
            ++deleteOffset;
          }
        }
      }
      current.update(event);

      //dispatch
      for(TimeDatasetObserver sub:subscribers){
        sub.onData(this, last, numAdded);
      }
      return numAdded;
    } else if (time >= current.getTime()) {
      current.update(event);
      return numAdded;
    } else {
      log.warn("reject late event {} {}", TimeSeriesUtil.timetoStr(time),
               TimeSeriesUtil.timetoStr(current.getTime()));
      return -1;
    }
  }


  @Override
  public void init(long time) {
    long ttime = truncate(time);
    current = makeElement();
    current.setTime(ttime);
    list.add(current);
    nextTime = schedule.next(ttime);
  }

  @Override
  public int size() {
    return list.size();
  }

  @Override
  public T getElement(long time) {
    if (!schedule.isValid(time)) {
      time = schedule.next(time);
    }
    int index = Ordering.natural().binarySearch(list, new BaseDataElement(time));
    return list.get(index);
  }

  @Override
  public T first() {
    return list.get(0);
  }

  @Override
  public T current() {
    return current;
  }

  @Override
  public T last() {
    return last;
  }

  @Override
  public Iterator<T> iterator() {
    return list.iterator();
  }

  /**
   * Get a cursor with 1 element
   */
  public Cursor<T> getCursor() {
    int index = Ordering.natural().binarySearch(list, new BaseDataElement(first().getTime()));
    return new Cursor<T>(this, index, 1);
  }

  /**
   * 1 = current
   * 0 = last item
   * -1 = before last
   * @param offset
   * @return
   */
  public Cursor<T> getCursorLastOffset(int offset) {
    return new Cursor<T>(this, list.size() - 2 + offset, 1);
  }

  public Cursor<T> getCursor(long time) {
    return getCursor(time, 1);
  }

  public Cursor<T> getCursor(long time, int numElement) {
    if (!schedule.isValid(time)) {
      time = schedule.next(time);
    }
    int index = Ordering.natural().binarySearch(list, new BaseDataElement(time));
    return new Cursor<T>(this, index, numElement);
  }

  public class Cursor<T extends DataElement> implements Iterator<T>, Iterable<T> {

    private TimeSeries<T> series;
    private T current;
    private T first;
    private int idx;
    private int numElement = 1;

    public Cursor(TimeSeries<T> series, int idx, int numElement) {
      this.idx = idx;
      this.series = series;
      this.numElement = 1;
      this.first = (T) list.get(Math.max(0, idx - numElement - 1));
      this.current = (T) list.get(idx);
    }

    /**
     * Returns {@code true} if the iteration has more elements. (In other words, returns {@code
     * true} if {@link #next} would return an element rather than throwing an exception.)
     *
     * @return {@code true} if the iteration has more elements
     */
    @Override
    public boolean hasNext() {
      return list.size() > (idx - series.deleteOffset);
    }

    public T next() {
      int currentIdx = idx - series.deleteOffset;
      this.first = series.list.get(Math.max(0, currentIdx - numElement - 1));
      this.current = series.list.get(currentIdx);
      idx++;
      return current;
    }


    /**
     * Removes from the underlying collection the last element returned by this iterator (optional
     * operation).  This method can be called only once per call to {@link #next}.  The behavior of
     * an iterator is unspecified if the underlying collection is modified while the iteration is in
     * progress in any way other than by calling this method.
     *
     * @throws UnsupportedOperationException if the {@code remove} operation is not supported by
     *                                       this iterator
     * @throws IllegalStateException         if the {@code next} method has not yet been called, or
     *                                       the {@code remove} method has already been called after
     *                                       the last call to the {@code next} method
     */
    @Override
    public void remove() {
      throw new RuntimeException("remove not supported for cursor");
    }

    public T first() {
      return first;
    }

    public T current() {
      return current;
    }

    /**
     * Returns an iterator over a set of elements of type T.
     *
     * @return an Iterator.
     */
    @Override
    public Iterator<T> iterator() {
      return this;
    }
  }
}
