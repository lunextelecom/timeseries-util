package com.lunex.timeseries;

import com.lunex.timeseries.element.DataElement;

import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 * In-memory version of timeseries, whatever added will just be in the Array and will not get
 * expired out if seriesSize is not set. To expired old bucket, set seriesSize to have fix memory usage.
 */
public class TimeSeries<T extends DataElement> extends TimeSeriesBase<T> implements TimeDataset<T>, Iterable<T> {

  private final Logger log = LoggerFactory.getLogger(TimeSeries.class);

  private List<T> list = new ArrayList();
  private T current = null;
  private T last = null;
  private TimeSchedule schedule = null;


  private int seriesSize = -1; //set this to a fix number to prevent over memory usage. default t0 100000

  public TimeSeries(String key, int elementSize) {
    this(key, elementSize, AggregateType.avg, null, 100000);
  }

  public TimeSeries(String key, int elementSize, AggregateType type,  int seriesSize) {
    this(key, elementSize, type, null, seriesSize);
  }

    public TimeSeries(String key, int elementSize, AggregateType type, TimeSchedule schedule, int seriesSize) {
    log.debug("TimeSeries {} created", key);
    this.key = key;
    this.elementSize = elementSize;
    this.type = type;
    this.seriesSize = seriesSize;
    if (schedule == null){
      this.schedule = new TimeSchedule.AllDayAllWeek(elementSize);
    }
    else{
      this.schedule = schedule;
    }
  }

  /**
   * reason for having time, and event.getTime().  Time is controlled by the system, so we will not go backward or out of order.
   * event.getTime() is generated by client, so they can send us a packet 1 hour late.
   * late event that are not withint the current will be rejected.
   * @param time - the time generate by the sender, it might not necessary be the time of the event
   * @param event - the time Event object
   * @return
   */
  long nextTime;
  public boolean onEvent(long time, TimeEvent event) {



//
//    log.debug("event {} next {} cur {}", TimeSeriesUtil.timetoStr(event.getTime()), TimeSeriesUtil.timetoStr(next), TimeSeriesUtil.timetoStr(current.getTime()));
//    int isNext = schedule.isNext(current.getTime(), event.getTime());
//    if (next == -1 &&){
//      return false;
//    }
//    if (event.getTime() >= next) {


    if ((time - current.getTime() >= elementSize)) {
      //the new event is
      long ttime = truncate(time);
      nextTime = schedule.next(ttime);
      log.debug("event {} next {} cur {}", TimeSeriesUtil.timetoStr(time), TimeSeriesUtil.timetoStr(nextTime), TimeSeriesUtil.timetoStr(current.getTime()));

      if (nextTime > ttime + elementSize)
        return false;
      last = current;
      current = makeElement();
      current.setTime(ttime);

      list.add(current);

      if (seriesSize != -1) {
//        long cutofftime = current().getTime() - elementSize * seriesSize;
        long cutofftime = schedule.prev(current.getTime(), seriesSize);
        if (cutofftime != -1){

          while (first().getTime() < cutofftime  ) {
            log.debug("{} < {}", TimeSeriesUtil.timetoStr(first().getTime()), TimeSeriesUtil.timetoStr(cutofftime));
            list.remove(0);
        }}
      }
      current.update(event);
      return true;
    }
    else if (time >= current.getTime()) {
      current.update(event);
      return false;
    }
    else{
      log.warn("reject late event {} {}", TimeSeriesUtil.timetoStr(time), TimeSeriesUtil.timetoStr(current.getTime()));
      return false;
    }
  }


  @Override
  public void init(long time) {
    long ttime = truncate(time);
    current = makeElement();
    current.setTime(ttime);
    list.add(current);
    nextTime = schedule.next(ttime);
  }

  @Override
  public int size() {
    return list.size();
  }

  @Override
  public T getData(long time) {
    //todo need better implementation
    //truncate time
    for (T item : list) {
      if (item.getTime() >= time) {
        return item;
      }
    }
    return null;
  }

  @Override
  public T first() {
    return list.get(0);
  }

  @Override
  public T current() {
    return current;
  }

  @Override
  public T last() {
    return last;
  }

  @Override
  public Iterator<T> iterator() {
    return list.iterator();
  }

}
